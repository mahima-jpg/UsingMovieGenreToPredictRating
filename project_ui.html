<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Does Genre Predict Movie Ratings?</title>
  <style>
    body 
    {
      margin: 20px;
      background-color: #ffffff;  
    }

    h1 
    {
      margin-top: 20px;
    }

    h2 
    {
      margin-top: 20px;
    }

    h3
    {
      margin-top: 20px;
    }

    p 
    {
      font-size: 0.95rem;
      line-height: 1.4;
    }

    section 
    {
      border: 1px solid #ddd;
      padding: 12px 16px;
      margin-bottom: 20px;
    }

    pre 
    {
      background-color: #f4f4f4;
      padding: 8px;
      border: 1px solid #ccc;
      overflow-x: auto;
      font-size: 0.85rem;
    }
    img {
      max-width: 100%;
      height: auto;
      border: 1px solid #ccc;
      margin-top: 8px;
    }
  
  </style>
</head>
<body>
  <h1>Predicting Movie Ratings</h1>
  <p>
    This page shows the sample SQL query results and visualizations from the movie ratings project.
    The data comes from MovieLens (kaggle datasets), stored in SQLite, and processed using pandas and SQL.
  </p>

  <section>
    <h2>1. Aggregate Ratings Per Movie (MovieRatings)</h2>
    <p>
      First, we aggregate all raw ratings into MovieRatings, so each movie has
      a total number of ratings and an average rating. This compresses millions of rows
      into one row per movie.
    </p>
    <h3>SQL Query</h3>
    
    <pre><code>
      CREATE TABLE MovieRatings AS
      SELECT
          r.movieId,
          COUNT(*) AS num_ratings,
          AVG(r.rating) AS avg_rating
      FROM RatingsRaw r
      GROUP BY r.movieId;
    </code></pre>

    <h3>Results (first 10 movies)</h3>
    <p>Sample output from the terminal showing the first 10 rows of MovieRatings:</p>
    <img src="images/aggregate.png" alt="Output of MovieRatings table from terminal">
    <p> In the first 10 rows, we can see that each movieId has anywhere from a few thousand up to tens of thousands of ratings. 
      The average ratings mostly sit around 3 to 4 stars, which makes sense because user ratings usually cluster in the middle
      instead of at the extreme 1 or 5 values.
    </p>
  </section>

  <section>
    <h2>2. Cleaned Movie Table (MovieRatingsClean)</h2>
    <p>
      Movies were joined with their aggregated ratings, their release year are extracted from the title,
      and filter to movies with at least 50 ratings released between 1980 and 2024.
      There is also a binary label high_rating for average rating â‰¥ 4.0.
    </p>
    <h3>SQL Query</h3>
    <pre><code>
      CREATE TABLE MovieRatingsClean AS
      SELECT
          movieId,
          title,
          genres,
          year,
          num_ratings,
          avg_rating,
          CASE WHEN avg_rating &gt;= 4.0 THEN 1 ELSE 0 END AS high_rating
      FROM MovieRatingsFull
      WHERE num_ratings &gt;= 50
        AND year BETWEEN 1980 AND 2024;</code></pre>

    <h3>Results (first 10 rows)</h3>
    <img src="images/clean.png" alt="Output of MovieRatingsClean table from terminal">

    <h3>Rating Distribution</h3>

    <h3>Histogram of Average Movie Ratings</h3>
    <img src="images/rating_hist.png" alt="Histogram of average movie ratings">

    <p> 
      The histogram of average movie ratings shows that most movies fall between about 2.5 and 3.8 stars. There is a clear peak around 3.3 to 3.5, and it is slightly skewed left. 
      There are very few movies with extremely low average ratings (below 2) or extremely high ones (above 4), 
      so the distribution is tightly packed in the middle. This suggests that users tend to give moderate scores. 
    </p>
  </section>

  <section>
    <h2>3. Checking for Suspicious Years</h2>
    <p>
      MovieRatingsFull was checked for movies with missing or suspicious years
      (before 1900, after 2100, or NULL). These rows are excluded by the year filter
      in MovieRatingsClean.
    </p>
    <h3>SQL Query</h3>
    <pre><code>
      SELECT 
        movieId, 
        title, year
      FROM MovieRatingsFull
      WHERE year &lt; 1900 OR year &gt; 2100 OR year IS NULL
      LIMIT 10;
    </code></pre>
    <h3>Empty DataFrame</h3>

  </section>

  <section>
    <h2>4. Per-Genre Summary (MovieGenreSummary)</h2>
    <p>
      After exploding the pipe-separated genre field into one row per (movie, genre), each genre was summarized:
    </p>
    <ul>
      <li>n_movies: Number of movies with that genre</li>
      <li>avg_movie_rating: Average of each movie's average rating</li>
      <li>share_high_rating: Fraction of movies with high_rating = 1</li>
    </ul>

    <h3>SQL Query</h3>
    <pre><code>
      CREATE TABLE MovieGenreSummary AS
      SELECT
        genre,
        COUNT(DISTINCT movieId) AS n_movies,
        AVG(avg_rating) AS avg_movie_rating,
        AVG(num_ratings) AS avg_num_ratings,
        AVG(high_rating) AS share_high_rating
      FROM MovieGenreRatings
      GROUP BY genre
      HAVING n_movies &gt;= 20;
    </code></pre>

    <h3>Genres and Average Rating</h3>
    <img src="images/genre.png" alt="Average rating by genre">
    
    <h3>Average Rating by Genre (All Genres)</h3>
    <img src="images/genre_avg_rating.png" alt="Average rating by genre">

    <p> 
      This bar chart compares the average movie rating across genres in our cleaned sample (only genres with at least 20 movies). Genres like Documentary, Film-Noir, and War have the highest average ratings, around 3.5 to 3.6, 
      while Children and Horror are at the lowest, closer to 2.8 to 3.0. More mainstream genres such as Action and Comedy are in the middle. 
      Overall, genre does matter, but it does not completely determine quality as every genre has both well-liked and less-liked movies. 
    </p>
  </section>


    <!-- FINISH? -->

</body>
</html>
